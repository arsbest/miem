#include "dict.h"

#include "mainwindow.h"
#include <QApplication>
#include <QHash>

#include <QDebug>

using namespace std;

int main(int argc, char *argv[])
{
//    QApplication a(argc, argv);
//    MainWindow w;
//    w.show();

//    return a.exec();

    Dict<string> d;

    // конструктор по умолчанию: (размер коллекции == 0)
    assert(d.size() == 0);

    // метод добавления объекта: (при добавлении нового объекта размер коллекции
    // увеличивается на единицу, а при добавлении имеющегося объекта
    // размер не изменяется)
    d.insert("Word 1");
    assert(d.size() == 1);
    d.insert("Word 1");
    assert(d.size() == 1);

    // метод проверки на наличие ключа: (в коллекции присутствует добавленный объект)
    assert(d.contains("Word 1") == true);

    // метод удаления объекта: (при удалении существующего объекта размер коллекции уменьшается на
    // единицу, а при удалении отсутствующего объекта размер не изменяется)
    d.remove("Word 1");
    assert(d.size() == 0);
    Uint prevSize = d.size();
    d.remove("Word 2");
    assert(d.size() == prevSize);

    // метод проверки на наличие ключа: (в коллекции отсутствует удалённый объект)
    assert(d.contains("Word 1") == false);

    // метод удаления всех объектов: (непустая коллекция после удаления всех объектов становится равна
    // коллекции, созданной при помощи конструктора по умолчанию)
    d.insert("Word 1");
    d.insert("Word 1");
    d.insert("Word 2");
    d.insert("Word 2");
    d.clear();
    // todo
    // assert(d == Dict<string>());

    // (варианты 4–15) оператор []: (значение, связанное с добавленным ключом, равно ожидаемому)
    d.insert("Word 1");
    d.insert("Word 1");
    d.insert("Word 2");
    d.insert("Word 2");
    d.insert("Word 2");
    assert(d["Word 1"] == 2);
    assert(d["Word 2"] == 3);

    // (варианты 4–6) при объединении двух не совпадающих коллекций, оператор || возвращает кол-
    // лекцию, размер которой равен сумме размеров слагаемых; при объединении двух идентичных кол-
    // лекций, возвращает не равную им (при ненулевых значениях) новую коллекцию того же размера

    // конструктор копирования: (копия непустой коллекции равна оригиналу, после вставки/удаления
    // объекта (варианты 1–3) или изменения одного из значений (варианты 4–15) равенство нарушается)

    // операторы << и >>: (проверка, аналогичная конструктору копирования)

    // Работа итератора проверяется выводом содержимого непустой коллекции на экран.

//    for (auto it = d.begin(); it != d.end(); it++) {
//        qDebug() << it.word().c_str() << it.count();
//    }
    auto it2 = d.begin();
    qDebug() << it2.word().c_str() << it2.count();
    it2++;
    it2++;
    it2++;
    it2++;
    it2++;
    it2++;
    qDebug() << it2.word().c_str() << it2.count();
    cout << d;

//    QHash<const char*, int> q;
//    q.insert("123", 1);
//    q.insert("777", 211);
//    for (QHash<const char*, int>::iterator qit = q.begin(); qit != q.end(); ++qit) {
//        qDebug() << qit.key() << qit.value();
//    }

    return 0;
}
